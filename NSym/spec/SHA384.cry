// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
//  SPDX-License-Identifier: Apache-2.0

module SHA384 where

import Array
import SHA384rec

processBlock_Common
processBlocks

///////////////////////////////////////////////////////////////////////////////
// SHA imperative specification
///////////////////////////////////////////////////////////////////////////////

/*
 * This section contains an SHA specification that more closely matches the
 * BoringSSL C implementation to simplify SAW correctness proofs of the
 * implementation.
 */

//////// Imperative top level ////////

type SHAState = { h : [8][w]
                , block : [w * 2][8]
                , n : [32]
                , sz : [w * 2]
                }

// Initial state for SHA
SHAInit : SHAState
SHAInit = { h = H0
          , block = zero
          , n = 0
          , sz = 0
          }

// Process message being hashed, iteratively updating the SHA state with the
// input message.
SHAUpdate : {n} (fin n) => SHAState -> [n][8] -> SHAState
SHAUpdate sinit bs = ss!0
  where ss = [sinit] # [ SHAUpdate1 s b | s <- ss | b <- bs ]

// Add padding and size and process the final block.
SHAFinal : SHAState -> [digest_size]
SHAFinal s = take (join (processBlock_Common h b'))
  // Because the message is always made up of bytes, and the size is a
  // fixed number of bytes, the 1 pad will always be at least a byte.
  where s' = SHAUpdate1 s 0x80
        // Don't need to add zeros. They're already there. Just update
        // the count of bytes in this block. After adding the 1 pad, there
        // are two possible cases: the size will fit in the current block,
        // or it won't.
        (h, b) = if s'.n <= (`w*2 - (`w/4)) then (s'.h, s'.block)
                 else (processBlock_Common s'.h (split (join s'.block)), zero)
        b' = split (join b || (zero # s.sz))

// Imperative SHA implementation
SHAImp : {n} (fin n) => [n][8] -> [digest_size]
SHAImp msg = SHAFinal (SHAUpdate SHAInit msg)


private

  // SHAUpdate1 updates a single byte at position s.n in s.block and return a
  // new state to pass to subsequent updates.  If s.n is 128, updates position 0
  // to b and zeros the remainder of the block, setting s.n to 1 for the next
  // update.
  SHAUpdate1 : SHAState -> [8] -> SHAState
  SHAUpdate1 s b =
    if s.n == (2 * `w - 1)
      then { h = processBlock_Common s.h (split (join (update s.block s.n b)))
           , block = zero
           , n = 0
           , sz = s.sz + 8
           }
      else { h = s.h
           , block = update s.block s.n b
           , n = s.n + 1
           , sz = s.sz + 8
           }


///////////////////////////////////////////////////////////////////////////////
// SHA imperative specification - SMT Array
///////////////////////////////////////////////////////////////////////////////

type SHAState_Array =
  { h : [8][w]
  , block : ByteArray
  , n : [32]
  , sz : [w * 2]
  }

SHAInit_Array : SHAState_Array
SHAInit_Array =
  { h = H0
  , block = arrayConstant 0
  , n = 0
  , sz = 0
  }

SHAUpdate_Array : (w >= 32) => SHAState_Array -> ByteArray -> [64] -> SHAState_Array
SHAUpdate_Array state data len =
  if state.n != 0
    then if len < 2 * `w - n
      then state'
      else state''
    else state'''
 where
   n = 0 # state.n
   state' = { h = state.h, block = block', n = drop n', sz = state.sz + (0 # len) * 8 }
    where
      block' = arrayCopy state.block n data 0 len
      n' = n + len
   state'' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }
    where
      h' = processBlock state.h (arrayCopy state.block n data 0 (2 * `w - n)) 0
      block' = arrayCopy state.block n data 0 (2 * `w - n)
      index' = 2 * `w - n
      len' = len - (2 * `w - n)
      (h'', index'', len'') = if len' >= 2 * `w
        then
          ( (processBlocks h' (arrayCopy (arrayConstant 0) 0 data index' ((len' / (2 * `w)) * (2 * `w))) 0 (len' / (2 * `w)))
          , index' + len' - (len' % (2 * `w))
          , len' % (2 * `w)
          )
        else (h', index', len')
      (block''', n''') = if len'' != 0
        then ((arrayCopy block' 0 data index'' len''), len'')
        else (block', 0)
   state''' = { h = h'', block = block''', n = drop n''', sz = state.sz + (0 # len) * 8 }
    where
      (h'', index'', len'') = if len >= 2 * `w
        then
          ( (processBlocks state.h data 0 (len / (2 * `w)))
          , len - (len % (2 * `w))
          , len % (2 * `w)
          )
        else (state.h, 0, len)
      (block''', n''') = if len'' != 0
        then ((arrayCopy state.block 0 data index'' len''), len'')
        else (state.block, n)

SHAFinal_Array : (w >= 32) => SHAState_Array -> [digest_size]
SHAFinal_Array state = take (join h''')
  where
    n = 0 # state.n
    block' = arrayUpdate state.block n 0x80
    n' = n + 1
    (h'', block'', n'') = if n' > 2 * `w - `w / 4
      then ((processBlock state.h (arraySet block' n' 0 (2 * `w - n')) 0), (arraySet block' n' 0 (2 * `w - n')), 0)
      else (state.h, block', n')
    h''' = processBlock
      h''
      (arrayRangeUpdate
        (arraySet block'' n'' 0 (2 * `w - `w / 4 - n''))
        (2 * `w - `w / 4)
        (split`{parts=(w+3)/4} (0 # state.sz)))
      0

// Imperative SHA implementation
SHAImp_Array : (w >= 32) => ByteArray -> [64] -> [digest_size]
SHAImp_Array msg len = SHAFinal_Array (SHAUpdate_Array SHAInit_Array msg len)


processBlocks : [8][w] -> ByteArray -> [64] -> [64] -> [8][w]
processBlocks [a, b, c, d, e, f, g, h] data index n = processBlock [a', b', c', d', e', f', g', h'] data index'
  where
    (a', b', c', d', e', f', g', h', index') = processBlocksLoop n data a b c d e f g h index

processBlock : [8][w] -> ByteArray -> [64] -> [8][w]
processBlock h block index =
  processBlock_Common h (split (join (arrayRangeLookup block index)))

processBlocksLoop : [64] -> ByteArray -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [w] -> [64] -> ([w], [w], [w], [w], [w], [w], [w], [w], [64])
processBlocksLoop num data a b c d e f g h index = if (index + 2 * `w) < (num * 2 * `w)
  then processBlocksLoop num data a' b' c' d' e' f' g' h' (index + 2 * `w)
  else (a, b, c, d, e, f, g, h, index)
  where
    [a', b', c', d', e', f', g', h'] = (processBlock [a, b, c, d, e, f, g, h] data index)

arrayRangeEqual_arrayRangeLookup_lemma : {n} (fin n, n >= 1, n <= 1000) => ByteArray -> ByteArray -> Bit
arrayRangeEqual_arrayRangeLookup_lemma a b = arrayRangeEqual a 0 b 0 `n == (arrayRangeLookup`{n=n} a 0 == arrayRangeLookup b 0)

type digest_size = 384
type digestsize_bytes = 48
type blocksize_bytes = 128

SHAInit_Array2 : SHAState_Array -> SHAState_Array
SHAInit_Array2 state = { h = SHAInit_Array.h
                       , block = state.block
                       , n = 0
                       , sz = 0 }

SHAImp_Array2 : SHAState_Array -> ByteArray -> [64] -> [digest_size]
SHAImp_Array2 state msg msg_len = SHAFinal_Array (SHAUpdate_Array (SHAInit_Array2 state) msg msg_len)

SHAInit_Array_zeroized : SHAState_Array
SHAInit_Array_zeroized =
  { h = zero
  , block = arrayConstant 0
  , n = 0
  , sz = 0
  }

SHAInit_zeroized : SHAState
SHAInit_zeroized =
  { h = zero
  , block = zero
  , n = 0
  , sz = 0
  }

SHAState_eq : SHAState -> SHAState -> Bool
SHAState_eq state1 state2 =
     state1.block == state2.block
  /\ state1.h == state2.h
  /\ state1.n == state2.n
  /\ state1.sz == state2.sz

SHAState_Array_eq : SHAState_Array -> SHAState_Array -> Bool
SHAState_Array_eq state1 state2 =
     (arrayRangeEqual state1.block 0 state2.block 0 `(blocksize_bytes))
  /\ state1.h == state2.h
  /\ state1.n == state2.n
  /\ state1.sz == state2.sz
